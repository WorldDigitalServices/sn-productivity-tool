<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Productivity Tool</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            sn: {
              bg: 'var(--sn-stylekit-background-color, #ffffff)',
              fg: 'var(--sn-stylekit-foreground-color, #000000)',
              border: 'var(--sn-stylekit-border-color, #e5e5e5)',
              info: 'var(--sn-stylekit-info-color, #086dd6)',
              accent: 'var(--sn-stylekit-accent-color, #086dd6)',
            }
          }
        }
      }
    }
  </script>
  
  <!-- Day.js for dates -->
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/relativeTime.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isToday.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isTomorrow.js"></script>
  <script>
    dayjs.extend(dayjs_plugin_relativeTime);
    dayjs.extend(dayjs_plugin_isToday);
    dayjs.extend(dayjs_plugin_isTomorrow);
  </script>
  
  <!-- Alpine.js + Collapse plugin -->
  <script defer src="https://cdn.jsdelivr.net/npm/@alpinejs/collapse@3.x.x/dist/cdn.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  
  <style>
    /* SN theme CSS variables */
    :root {
      --sn-stylekit-background-color: #ffffff;
      --sn-stylekit-foreground-color: #1a1a1a;
      --sn-stylekit-border-color: #e5e7eb;
      --sn-stylekit-info-color: #3b82f6;
      --sn-stylekit-accent-color: #3b82f6;
      --sn-stylekit-contrast-background-color: #f3f4f6;
    }
    .dark {
      --sn-stylekit-background-color: #1a1a1a;
      --sn-stylekit-foreground-color: #f5f5f5;
      --sn-stylekit-border-color: #374151;
      --sn-stylekit-info-color: #60a5fa;
      --sn-stylekit-accent-color: #60a5fa;
      --sn-stylekit-contrast-background-color: #262626;
    }
    
    /* Base styles */
    * { box-sizing: border-box; }
    html, body { 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    /* Scrollbar styling */
    .custom-scroll::-webkit-scrollbar { width: 6px; }
    .custom-scroll::-webkit-scrollbar-track { background: transparent; }
    .custom-scroll::-webkit-scrollbar-thumb { 
      background: var(--sn-stylekit-border-color); 
      border-radius: 3px; 
    }
    
    /* Weight indicator colors - more prominent */
    .weight-1 { background: linear-gradient(180deg, #94a3b8, #64748b); box-shadow: 0 0 4px rgba(148, 163, 184, 0.5); }
    .weight-2 { background: linear-gradient(180deg, #60a5fa, #3b82f6); box-shadow: 0 0 4px rgba(96, 165, 250, 0.5); }
    .weight-3 { background: linear-gradient(180deg, #fbbf24, #f59e0b); box-shadow: 0 0 4px rgba(251, 191, 36, 0.5); }
    .weight-4 { background: linear-gradient(180deg, #fb923c, #ea580c); box-shadow: 0 0 4px rgba(251, 146, 60, 0.5); }
    .weight-5 { background: linear-gradient(180deg, #f87171, #dc2626); box-shadow: 0 0 6px rgba(239, 68, 68, 0.6); }
    
    /* Timer pulse animation */
    @keyframes pulse-timer {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .timer-active { animation: pulse-timer 1.5s ease-in-out infinite; }
    
    /* Transitions */
    .task-item { transition: all 0.2s ease; }
    .task-item.completed { opacity: 0.6; }
    
    /* Input styling */
    input[type="date"]::-webkit-calendar-picker-indicator {
      filter: var(--date-picker-filter, none);
    }
    .dark input[type="date"]::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }
  </style>
  
  <script>
    // =====================================================
    // SN EXTENSION API - Extracted from sn-extension-api@0.4.0
    // This is the PROVEN working implementation
    // =====================================================
    (function() {
      var Actions = {
        StreamContextItem: "stream-context-item",
        SaveItems: "save-items",
        ComponentRegistered: "component-registered",
        ActivateThemes: "themes",
        ThemesActivated: "themes-activated",
        SetComponentData: "set-component-data"
      };
      
      var ApiType = {
        Component: "component"
      };
      
      var snApi = {
        component: { activeThemes: [], acceptsThemes: true },
        sentMessages: [],
        messageQueue: [],
        subscriptions: [],
        generateNotePreview: true,
        contentWindow: null,
        lastStreamedItem: null,
        coallesedSavingDelay: 250,
        pendingSaveTimeout: null,
        pendingSaveParams: null,
        pendingSaveItems: null,
        
        initialize: function(options) {
          options = options || {};
          if (this.contentWindow) {
            throw "Cannot initialize mediator more than once";
          }
          this.contentWindow = window;
          this.coallesedSavingDelay = options.debounceSave !== undefined ? options.debounceSave : 250;
          this.registerMessageHandler();
          
          var self = this;
          this.postMessage(Actions.StreamContextItem, {}, function(response) {
            var item = response.item;
            if ((!self.lastStreamedItem || self.lastStreamedItem.uuid !== item.uuid) && self.pendingSaveTimeout) {
              clearTimeout(self.pendingSaveTimeout);
              self.performSavingOfItems(self.pendingSaveParams);
              self.pendingSaveTimeout = undefined;
              self.pendingSaveParams = undefined;
            }
            self.lastStreamedItem = item;
            if (!self.lastStreamedItem.isMetadataUpdate) {
              self.subscriptions.forEach(function(cb) {
                cb(self.text, self.meta);
              });
            }
          });
        },
        
        subscribe: function(callback) {
          this.subscriptions.push(callback);
          var self = this;
          if (this.lastStreamedItem) {
            setTimeout(function() {
              callback(self.text, self.meta);
            });
          }
          return function() {
            var idx = self.subscriptions.indexOf(callback);
            if (idx >= 0) self.subscriptions.splice(idx, 1);
          };
        },
        
        get text() {
          this.checkNoteExists();
          var item = this.lastStreamedItem;
          return (item && item.content && item.content.text) || "";
        },
        
        set text(value) {
          this.checkNoteExists();
          this.lastStreamedItem.content.text = value;
          this.saveNote(this.lastStreamedItem);
        },
        
        get meta() {
          this.checkNoteExists();
          var item = this.lastStreamedItem;
          if (item && item.content) {
            return item.content.appData[item.content.editorIdentifier] || {};
          }
          return {};
        },
        
        set meta(value) {
          this.checkNoteExists();
          this.lastStreamedItem.content.appData[this.lastStreamedItem.content.editorIdentifier] = value;
          this.saveNote(this.lastStreamedItem);
        },
        
        get locked() {
          this.checkNoteExists();
          var item = this.lastStreamedItem;
          return item && item.content && item.content.appData && 
                 item.content.appData["org.standardnotes.sn"] &&
                 item.content.appData["org.standardnotes.sn"].locked;
        },
        
        get preview() {
          this.checkNoteExists();
          var item = this.lastStreamedItem;
          return item && item.content && item.content.preview_plain;
        },
        
        set preview(value) {
          this.checkNoteExists();
          this.generateNotePreview = false;
          this.lastStreamedItem.content.preview_plain = value;
        },
        
        get isRunningInDesktopApplication() {
          return this.component.environment === "desktop";
        },
        
        get isRunningInMobileApplication() {
          return this.component.environment === "mobile";
        },
        
        get isRunningInBrowser() {
          return this.component.environment === "web";
        },
        
        registerMessageHandler: function() {
          var self = this;
          
          function isJsonString(str) {
            if (typeof str !== "string") return false;
            try {
              var result = JSON.parse(str);
              var type = Object.prototype.toString.call(result);
              return type === "[object Object]" || type === "[object Array]";
            } catch (e) {
              return false;
            }
          }
          
          this.messageHandler = function(event) {
            var data = event.data;
            var parsed = isJsonString(data) ? JSON.parse(data) : data;
            if (parsed) {
              self.handleMessage(parsed);
            }
          };
          
          // Listen on both document and window - this is key for mobile compatibility
          this.contentWindow.document.addEventListener("message", this.messageHandler, false);
          this.contentWindow.addEventListener("message", this.messageHandler, false);
        },
        
        handleMessage: function(message) {
          var self = this;
          
          switch (message.action) {
            case Actions.ComponentRegistered:
              this.component.sessionKey = message.sessionKey;
              if (message.componentData) {
                this.component.data = message.componentData;
              }
              this.onReady(message.data);
              break;
              
            case Actions.ActivateThemes:
              this.activateThemes(message.data.themes);
              break;
              
            default:
              if (!message.original) return;
              var sent = this.sentMessages.filter(function(m) {
                return m.messageId === message.original.messageId;
              })[0];
              if (sent && sent.callback) {
                sent.callback(message.data);
              }
              break;
          }
        },
        
        onReady: function(data) {
          this.component.environment = data.environment;
          this.component.platform = data.platform;
          this.component.uuid = data.uuid;
          
          // Process queued messages
          var self = this;
          this.messageQueue.forEach(function(queued) {
            self.postMessage(queued.action, queued.data, queued.callback);
          });
          this.messageQueue = [];
          
          this.activateThemes(data.activeThemeUrls || []);
          this.postMessage(Actions.ThemesActivated, {});
        },
        
        postMessage: function(action, data, callback) {
          // Queue if not yet registered
          if (!this.component.sessionKey) {
            this.messageQueue.push({
              action: action,
              data: data,
              api: ApiType.Component,
              callback: callback
            });
            return;
          }
          
          var message = {
            action: action,
            data: data,
            messageId: this.generateUUID(),
            sessionKey: this.component.sessionKey,
            api: ApiType.Component
          };
          
          var messageCopy = JSON.parse(JSON.stringify(message));
          messageCopy.callback = callback;
          this.sentMessages.push(messageCopy);
          
          // KEY DIFFERENCE: Stringify for mobile, object for desktop
          var toSend = this.isRunningInMobileApplication ? JSON.stringify(message) : message;
          
          // ONLY use parent.postMessage - no ReactNativeWebView
          this.contentWindow.parent.postMessage(toSend, "*");
        },
        
        activateThemes: function(urls) {
          urls = urls || [];
          if (!this.component.acceptsThemes) return;
          
          var activeThemes = this.component.activeThemes || [];
          if (activeThemes.sort().toString() === urls.sort().toString()) return;
          
          var toActivate = urls.slice();
          var toDeactivate = [];
          
          activeThemes.forEach(function(theme) {
            if (urls.includes(theme)) {
              toActivate = toActivate.filter(function(u) { return u !== theme; });
            } else {
              toDeactivate.push(theme);
            }
          });
          
          var self = this;
          toDeactivate.forEach(function(theme) {
            self.deactivateTheme(theme);
          });
          
          this.component.activeThemes = urls;
          
          toActivate.forEach(function(url) {
            if (!url) return;
            var link = self.contentWindow.document.createElement("link");
            link.id = btoa(url);
            link.href = url;
            link.type = "text/css";
            link.rel = "stylesheet";
            link.media = "screen,print";
            link.className = "custom-theme";
            self.contentWindow.document.getElementsByTagName("head")[0].appendChild(link);
          });
        },
        
        deactivateTheme: function(url) {
          var elements = this.contentWindow.document.getElementsByClassName("custom-theme");
          var el = Array.from(elements).find(function(e) { return e.id === btoa(url); });
          if (el && el.parentNode) {
            el.setAttribute("disabled", "true");
            el.parentNode.removeChild(el);
          }
        },
        
        generateUUID: function() {
          if (crypto.randomUUID) return crypto.randomUUID();
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0;
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
          });
        },
        
        performSavingOfItems: function(params) {
          var items = params.items;
          var callback = params.callback;
          
          if (this.generateNotePreview) {
            var text = items[0].content.text || "";
            items[0].content.preview_plain = text.length <= 50 ? text : text.substring(0, 50) + "...";
          }
          
          var self = this;
          var itemsToSave = items.map(function(item) {
            return self.jsonObjectForItem(item);
          });
          
          this.postMessage(Actions.SaveItems, { items: itemsToSave }, function() {
            if (callback) callback();
          });
        },
        
        saveNote: function(item, callback) {
          var items = [item];
          if (!this.pendingSaveItems) this.pendingSaveItems = [];
          
          if (this.coallesedSavingDelay) {
            if (this.pendingSaveTimeout) clearTimeout(this.pendingSaveTimeout);
            
            var uuids = items.map(function(i) { return i.uuid; });
            var existing = this.pendingSaveItems.filter(function(i) { return !uuids.includes(i.uuid); });
            this.pendingSaveItems = existing.concat(items);
            this.pendingSaveParams = { items: this.pendingSaveItems, callback: callback };
            
            var self = this;
            this.pendingSaveTimeout = setTimeout(function() {
              self.performSavingOfItems(self.pendingSaveParams);
              self.pendingSaveItems = [];
              self.pendingSaveTimeout = undefined;
              self.pendingSaveParams = null;
            }, this.coallesedSavingDelay);
          } else {
            this.performSavingOfItems({ items: items, callback: callback });
          }
        },
        
        jsonObjectForItem: function(item) {
          var copy = Object.assign({}, item);
          copy.children = null;
          copy.parent = null;
          return copy;
        },
        
        checkNoteExists: function() {
          if (!this.lastStreamedItem) {
            throw "Trying to interact with note before it is received from Standard Notes. Use subscribe function.";
          }
        }
      };
      
      // Expose globally
      window.snApi = snApi;
    })();
  </script>
</head>
<body>
  <div id="app" x-data="productivityApp()" x-init="init()" 
       :class="{ 'dark': darkMode }"
       class="h-full flex flex-col"
       style="background: var(--sn-stylekit-background-color); color: var(--sn-stylekit-foreground-color);">
    
    <!-- Header -->
    <header class="flex-shrink-0 px-4 py-3 border-b" style="border-color: var(--sn-stylekit-border-color);">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <h1 class="text-lg font-semibold">Tasks</h1>
          <span class="text-sm opacity-60" x-text="progressText"></span>
          <span x-show="inStandardNotes" class="w-2 h-2 rounded-full bg-green-500" title="Synced with Standard Notes"></span>
        </div>
        <div class="flex items-center gap-2">
          <div class="flex rounded-lg overflow-hidden border" style="border-color: var(--sn-stylekit-border-color);">
            <button @click.prevent="viewMode = 'list'" 
                    class="px-3 py-2 text-sm min-h-[44px] transition-colors"
                    :style="viewMode === 'list' ? 'background: var(--sn-stylekit-accent-color); color: white;' : 'background: var(--sn-stylekit-contrast-background-color);'">
              List
            </button>
            <button @click.prevent="viewMode = 'kanban'" 
                    class="px-3 py-2 text-sm min-h-[44px] transition-colors"
                    :style="viewMode === 'kanban' ? 'background: var(--sn-stylekit-accent-color); color: white;' : 'background: var(--sn-stylekit-contrast-background-color);'">
              Kanban
            </button>
            <button @click.prevent="viewMode = 'matrix'" 
                    class="px-3 py-2 text-sm min-h-[44px] transition-colors"
                    :style="viewMode === 'matrix' ? 'background: var(--sn-stylekit-accent-color); color: white;' : 'background: var(--sn-stylekit-contrast-background-color);'">
              Matrix
            </button>
          </div>
          
          <button x-show="viewMode === 'list'" @click.prevent="toggleSort()" 
                  class="p-2 rounded-lg hover:opacity-80 transition-opacity min-w-[44px] min-h-[44px] flex items-center justify-center"
                  :title="sortBy === 'weight' ? 'Sort by due date' : 'Sort by weight'"
                  style="background: var(--sn-stylekit-contrast-background-color);">
            <svg x-show="sortBy === 'weight'" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12"/>
            </svg>
            <svg x-show="sortBy === 'dueDate'" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
          </button>
          
          <button x-show="!inStandardNotes" @click.prevent="toggleDarkMode()" 
                  class="p-2 rounded-lg hover:opacity-80 transition-opacity min-w-[44px] min-h-[44px] flex items-center justify-center"
                  style="background: var(--sn-stylekit-contrast-background-color);">
            <svg x-show="!darkMode" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/>
            </svg>
            <svg x-show="darkMode" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z"/>
            </svg>
          </button>
          
          <button x-show="completedCount > 0" @click.prevent="clearCompleted()" 
                  class="px-3 py-2 text-sm rounded-lg hover:opacity-80 transition-opacity min-h-[44px]"
                  style="background: var(--sn-stylekit-contrast-background-color);">
            Clear done
          </button>
        </div>
      </div>
    </header>
    
    <!-- Task list view -->
    <main x-show="viewMode === 'list'" class="flex-1 overflow-y-auto custom-scroll px-4 py-3">
      <div class="mb-4" x-show="!locked">
        <div class="flex gap-2">
          <input type="text" 
                 x-model="newTaskText" 
                 @keydown.enter.prevent="addTask()"
                 placeholder="Add a task..."
                 :disabled="locked"
                 class="flex-1 px-4 py-3 rounded-lg border text-base min-h-[44px]"
                 style="background: var(--sn-stylekit-background-color); border-color: var(--sn-stylekit-border-color); color: var(--sn-stylekit-foreground-color);">
          <button @click.prevent="addTask()" 
                  :disabled="!newTaskText.trim() || locked"
                  class="px-4 py-3 rounded-lg font-medium min-w-[44px] min-h-[44px] disabled:opacity-50"
                  style="background: var(--sn-stylekit-accent-color); color: white;">
            Add
          </button>
        </div>
      </div>
      
      <div class="space-y-2">
        <template x-for="task in sortedTasks" :key="task.id">
          <div class="task-item rounded-lg border p-3"
               :class="{ 'completed': task.done }"
               style="border-color: var(--sn-stylekit-border-color);">
            <div class="flex items-center gap-3">
              <button @click.prevent="toggleTask(task)" 
                      :disabled="locked"
                      class="flex-shrink-0 w-6 h-6 rounded border-2 flex items-center justify-center min-w-[24px] min-h-[24px]"
                      :style="task.done ? 'background: var(--sn-stylekit-accent-color); border-color: var(--sn-stylekit-accent-color);' : 'border-color: var(--sn-stylekit-border-color);'">
                <svg x-show="task.done" class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                </svg>
              </button>
              
              <div class="flex-shrink-0 w-1.5 rounded-full shadow-sm" 
                   style="min-height: 2.5rem;"
                   :class="'weight-' + task.weight"></div>
              
              <div class="flex-1 min-w-0">
                <template x-if="editingTaskId !== task.id">
                  <div @click="!locked && startEditTask(task)" 
                       class="cursor-pointer break-words"
                       :class="{ 'line-through opacity-60': task.done }"
                       x-text="task.text"></div>
                </template>
                <template x-if="editingTaskId === task.id">
                  <input type="text" 
                         x-model="editingTaskText"
                         x-ref="editInput"
                         @keydown.enter.prevent="saveEditTask(task)"
                         @keydown.escape.prevent="cancelEditTask()"
                         @blur="saveEditTask(task)"
                         class="w-full px-2 py-1 rounded border text-base"
                         style="background: var(--sn-stylekit-background-color); border-color: var(--sn-stylekit-border-color); color: var(--sn-stylekit-foreground-color);">
                </template>
              </div>
              
              <div x-show="task.timerStartedAt" 
                   class="flex-shrink-0 text-sm font-mono timer-active"
                   style="color: var(--sn-stylekit-accent-color);">
                <span x-text="(timerTick, formatRunningTime(task))"></span><span x-show="task.estimatedMinutes" class="opacity-70">/<span x-text="formatEstimate(task)"></span></span>
              </div>
              
              <!-- Time tracking display (when not running but has time) -->
              <div x-show="!task.timerStartedAt && (task.trackedSeconds > 0 || task.estimatedMinutes)"
                   class="flex-shrink-0 text-xs font-mono opacity-70">
                <span x-text="formatTrackedTime(task)"></span><span x-show="task.estimatedMinutes">/<span x-text="formatEstimate(task)"></span> est.</span>
              </div>
              
              <div x-show="task.dueDate && !task.done" 
                   class="flex-shrink-0 text-xs px-2 py-1 rounded"
                   :class="getDueDateClass(task.dueDate)"
                   x-text="getDueDateText(task.dueDate)"></div>
              
              <div x-show="task.subtasks && task.subtasks.length > 0" 
                   class="flex-shrink-0 text-xs opacity-60"
                   x-text="getSubtaskProgress(task)"></div>
              
              <!-- Status badge -->
              <div x-show="!task.done && (task.status || defaultStatus) !== 'backlog'"
                   class="flex-shrink-0 text-xs px-2 py-1 rounded text-white"
                   :style="'background: ' + getStatusColor(task.status || defaultStatus)"
                   x-text="getStatusLabel(task.status || defaultStatus)"></div>
              
              <!-- Quadrant badge -->
              <div x-show="task.quadrant"
                   class="flex-shrink-0 text-xs px-2 py-1 rounded text-white"
                   :style="'background: ' + getQuadrantColor(task.quadrant)"
                   x-text="getQuadrantLabel(task.quadrant)"></div>
              
              <button @click.prevent="toggleExpanded(task)" 
                      class="flex-shrink-0 p-1 rounded hover:opacity-80 min-w-[32px] min-h-[32px] flex items-center justify-center"
                      style="background: var(--sn-stylekit-contrast-background-color);">
                <svg class="w-4 h-4 transition-transform" 
                     :class="{ 'rotate-180': expandedTaskId === task.id }"
                     fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                </svg>
              </button>
            </div>
            
            <div x-show="expandedTaskId === task.id" x-collapse class="mt-3 pt-3 border-t" style="border-color: var(--sn-stylekit-border-color);">
              <!-- Status selector -->
              <div class="flex items-center gap-2 mb-3 flex-wrap">
                <span class="text-sm opacity-60">Status:</span>
                <div class="flex flex-wrap gap-1">
                  <template x-for="status in statuses" :key="status.id">
                    <button @click.prevent="setTaskStatus(task, status.id)" :disabled="locked"
                            class="px-2 py-1 rounded text-xs min-h-[28px] transition-all"
                            :style="(task.status || defaultStatus) === status.id 
                              ? 'background: ' + status.color + '; color: white;' 
                              : 'background: var(--sn-stylekit-contrast-background-color); opacity: 0.7;'"
                            x-text="status.label"></button>
                  </template>
                </div>
              </div>
              
              <!-- Eisenhower Quadrant selector -->
              <div class="flex items-center gap-2 mb-3 flex-wrap">
                <span class="text-sm opacity-60">Quadrant:</span>
                <div class="flex flex-wrap gap-1">
                  <template x-for="quad in quadrants" :key="quad.id">
                    <button @click.prevent="setTaskQuadrant(task, quad.id)" :disabled="locked"
                            class="px-2 py-1 rounded text-xs min-h-[28px] transition-all"
                            :style="task.quadrant === quad.id 
                              ? 'background: ' + quad.color + '; color: white;' 
                              : 'background: var(--sn-stylekit-contrast-background-color); opacity: 0.7;'"
                            x-text="quad.label"></button>
                  </template>
                  <button x-show="task.quadrant" @click.prevent="setTaskQuadrant(task, null)" :disabled="locked"
                          class="px-2 py-1 rounded text-xs min-h-[28px] opacity-60 hover:opacity-100"
                          style="background: var(--sn-stylekit-contrast-background-color);">Clear</button>
                </div>
              </div>
              
              <!-- Priority -->
              <div class="flex items-center gap-2 mb-3">
                <span class="text-sm opacity-60">Priority:</span>
                <button @click.prevent="decreaseWeight(task)" :disabled="locked || task.weight <= 1"
                        class="px-2 py-1 rounded text-sm disabled:opacity-30 min-w-[32px] min-h-[32px]"
                        style="background: var(--sn-stylekit-contrast-background-color);">−</button>
                <span class="w-8 text-center font-medium" x-text="task.weight"></span>
                <button @click.prevent="increaseWeight(task)" :disabled="locked || task.weight >= 5"
                        class="px-2 py-1 rounded text-sm disabled:opacity-30 min-w-[32px] min-h-[32px]"
                        style="background: var(--sn-stylekit-contrast-background-color);">+</button>
              </div>
              
              <!-- Due date -->
              <div class="flex items-center gap-2 mb-3">
                <span class="text-sm opacity-60">Due:</span>
                <input type="date" :value="task.dueDate" @change="setDueDate(task, $event.target.value)" :disabled="locked"
                       class="px-2 py-1 rounded border text-sm min-h-[32px]"
                       style="background: var(--sn-stylekit-background-color); border-color: var(--sn-stylekit-border-color); color: var(--sn-stylekit-foreground-color);">
                <button x-show="task.dueDate" @click.prevent="setDueDate(task, null)" :disabled="locked"
                        class="text-xs opacity-60 hover:opacity-100 min-w-[32px] min-h-[32px]">Clear</button>
              </div>
              
              <!-- Time tracking -->
              <div class="flex items-center gap-2 mb-3">
                <span class="text-sm opacity-60">Time:</span>
                <span x-show="!task.timerStartedAt" class="font-mono text-sm" x-text="formatTrackedTime(task)"></span>
                <span x-show="task.timerStartedAt" class="font-mono text-sm timer-active" style="color: var(--sn-stylekit-accent-color);" x-text="(timerTick, formatRunningTime(task))"></span>
                <template x-if="task.estimatedMinutes">
                  <span class="text-sm opacity-60">/ <span x-text="formatEstimate(task)"></span> est.</span>
                </template>
                <button x-show="!task.timerStartedAt && !task.done" @click.prevent="startTimer(task)" :disabled="locked"
                        class="px-2 py-1 rounded text-xs min-h-[28px]" style="background: var(--sn-stylekit-accent-color); color: white;">Start</button>
                <button x-show="task.timerStartedAt" @click.prevent="stopTimer(task)"
                        class="px-2 py-1 rounded text-xs min-h-[28px]" style="background: #ef4444; color: white;">Stop</button>
              </div>
              
              <!-- Estimate -->
              <div class="flex items-center gap-2 mb-3">
                <span class="text-sm opacity-60">Estimate:</span>
                <input type="text" 
                       :value="formatEstimate(task)"
                       @blur="setEstimate(task, $event.target.value)"
                       @keydown.enter.prevent="$event.target.blur()"
                       :disabled="locked"
                       placeholder="e.g. 1h30m, 90m, 1:30"
                       class="px-2 py-1 rounded border text-sm w-32 min-h-[32px]"
                       style="background: var(--sn-stylekit-background-color); border-color: var(--sn-stylekit-border-color); color: var(--sn-stylekit-foreground-color);">
              </div>
              
              <div class="mb-3">
                <div class="text-sm opacity-60 mb-2">Subtasks:</div>
                <div class="space-y-1 mb-2">
                  <template x-for="subtask in (task.subtasks || [])" :key="subtask.id">
                    <div class="flex items-center gap-2 pl-2">
                      <button @click.prevent="toggleSubtask(task, subtask)" :disabled="locked"
                              class="flex-shrink-0 w-4 h-4 rounded border flex items-center justify-center"
                              :style="subtask.done ? 'background: var(--sn-stylekit-accent-color); border-color: var(--sn-stylekit-accent-color);' : 'border-color: var(--sn-stylekit-border-color);'">
                        <svg x-show="subtask.done" class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                          <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                        </svg>
                      </button>
                      <span class="flex-1 text-sm" :class="{ 'line-through opacity-60': subtask.done }" x-text="subtask.text"></span>
                      <button @click.prevent="deleteSubtask(task, subtask)" :disabled="locked"
                              class="text-xs opacity-40 hover:opacity-100 min-w-[24px] min-h-[24px]">×</button>
                    </div>
                  </template>
                </div>
                <div class="flex gap-2" x-show="!locked">
                  <input type="text" x-model="newSubtaskText" @keydown.enter.prevent="addSubtask(task)" placeholder="Add subtask..."
                         class="flex-1 px-2 py-1 rounded border text-sm min-h-[32px]"
                         style="background: var(--sn-stylekit-background-color); border-color: var(--sn-stylekit-border-color); color: var(--sn-stylekit-foreground-color);">
                  <button @click.prevent="addSubtask(task)" :disabled="!newSubtaskText.trim()"
                          class="px-2 py-1 rounded text-sm disabled:opacity-50 min-h-[32px]" style="background: var(--sn-stylekit-accent-color); color: white;">Add</button>
                </div>
              </div>
              
              <button @click.prevent="deleteTask(task)" :disabled="locked"
                      class="text-sm opacity-60 hover:opacity-100 min-h-[32px]" style="color: #ef4444;">Delete task</button>
            </div>
          </div>
        </template>
        
        <div x-show="items.length === 0" class="text-center py-12 opacity-60">
          <p>No tasks yet. Add one above!</p>
        </div>
      </div>
    </main>
    
    <!-- Kanban view -->
    <main x-show="viewMode === 'kanban'" class="flex-1 overflow-x-auto custom-scroll">
      <div class="flex gap-4 p-4 min-h-full">
        <template x-for="status in statuses" :key="status.id">
          <div class="flex-shrink-0 w-72 flex flex-col rounded-lg"
               style="background: var(--sn-stylekit-contrast-background-color);"
               @dragover.prevent="onDragOver($event)"
               @drop.prevent="onDrop($event, status.id)">
            <div class="px-3 py-2 border-b flex items-center justify-between" style="border-color: var(--sn-stylekit-border-color);">
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full" :style="'background: ' + status.color"></div>
                <span class="font-medium text-sm" x-text="status.label"></span>
              </div>
              <span class="text-xs opacity-60" x-text="getColumnCount(status.id)"></span>
            </div>
            <div class="flex-1 p-2 space-y-2 overflow-y-auto custom-scroll">
              <template x-for="task in getTasksByStatus(status.id)" :key="task.id">
                <div class="p-3 rounded-lg cursor-move" style="background: var(--sn-stylekit-background-color);"
                     draggable="true" @dragstart="onDragStart($event, task)" @dragend="onDragEnd($event)">
                  <div class="flex items-start gap-2">
                    <div class="flex-shrink-0 w-1.5 h-full min-h-[20px] rounded-full mt-1" :class="'weight-' + task.weight"></div>
                    <div class="flex-1 min-w-0">
                      <div class="text-sm break-words" x-text="task.text"></div>
                      <div class="flex items-center gap-2 mt-1 text-xs opacity-60">
                        <span x-show="task.dueDate" x-text="getDueDateText(task.dueDate)"></span>
                        <span x-show="task.subtasks && task.subtasks.length > 0" x-text="getSubtaskProgress(task)"></span>
                      </div>
                    </div>
                  </div>
                </div>
              </template>
            </div>
          </div>
        </template>
      </div>
    </main>
    
    <!-- Eisenhower Matrix view -->
    <main x-show="viewMode === 'matrix'" class="flex-1 overflow-auto custom-scroll p-4">
      <div class="grid grid-cols-2 grid-rows-2 gap-3 h-full min-h-[500px]">
        <template x-for="quad in quadrants" :key="quad.id">
          <div class="rounded-lg border-2 flex flex-col overflow-hidden"
               :style="'border-color: ' + quad.color + '; background: ' + quad.bg"
               @dragover.prevent="onDragOver($event)"
               @drop.prevent="onDropQuadrant($event, quad.id)">
            <!-- Quadrant header -->
            <div class="px-3 py-2 border-b flex items-center justify-between"
                 :style="'background: ' + quad.color + '; border-color: ' + quad.color">
              <div>
                <div class="font-semibold text-white text-sm" x-text="quad.label"></div>
                <div class="text-xs text-white opacity-80" x-text="quad.subtitle"></div>
              </div>
              <span class="text-xs text-white opacity-80 bg-white/20 px-2 py-0.5 rounded" 
                    x-text="getQuadrantCount(quad.id)"></span>
            </div>
            <!-- Quadrant tasks -->
            <div class="flex-1 p-2 overflow-y-auto custom-scroll">
              <div class="space-y-1.5">
                <template x-for="task in getTasksByQuadrant(quad.id)" :key="task.id">
                  <div class="px-2 py-1.5 rounded text-sm cursor-move flex items-center gap-2"
                       style="background: var(--sn-stylekit-background-color);"
                       draggable="true" 
                       @dragstart="onDragStart($event, task)" 
                       @dragend="onDragEnd($event)">
                    <div class="flex-shrink-0 w-1 h-4 rounded-full" :class="'weight-' + task.weight"></div>
                    <span class="truncate" :class="{ 'line-through opacity-50': task.done }" x-text="task.text"></span>
                  </div>
                </template>
                <div x-show="getTasksByQuadrant(quad.id).length === 0" 
                     class="text-center py-4 text-xs opacity-40">
                  Drag tasks here
                </div>
              </div>
            </div>
          </div>
        </template>
      </div>
      <!-- Unassigned tasks -->
      <div x-show="getUnassignedTasks().length > 0" class="mt-4 p-3 rounded-lg border" style="border-color: var(--sn-stylekit-border-color); background: var(--sn-stylekit-contrast-background-color);">
        <div class="text-sm font-medium mb-2 opacity-60">Unassigned to Matrix (<span x-text="getUnassignedTasks().length"></span>)</div>
        <div class="flex flex-wrap gap-2">
          <template x-for="task in getUnassignedTasks()" :key="task.id">
            <div class="px-2 py-1 rounded text-xs cursor-move flex items-center gap-1"
                 style="background: var(--sn-stylekit-background-color);"
                 draggable="true"
                 @dragstart="onDragStart($event, task)"
                 @dragend="onDragEnd($event)">
              <div class="w-1 h-3 rounded-full" :class="'weight-' + task.weight"></div>
              <span :class="{ 'line-through opacity-50': task.done }" x-text="task.text"></span>
            </div>
          </template>
        </div>
      </div>
    </main>
  </div>

  <script>
    var STATUSES = [
      { id: 'backlog', label: 'Backlog', color: '#64748b' },
      { id: 'scheduled', label: 'Scheduled', color: '#8b5cf6' },
      { id: 'ready', label: 'Ready', color: '#3b82f6' },
      { id: 'in-progress', label: 'In Progress', color: '#f59e0b' },
      { id: 'blocked', label: 'Blocked', color: '#ef4444' },
      { id: 'in-review', label: 'In Review', color: '#ec4899' },
      { id: 'waiting', label: 'Waiting', color: '#f97316' },
      { id: 'done', label: 'Done', color: '#22c55e' },
      { id: 'someday', label: 'Someday', color: '#6b7280' }
    ];
    var DEFAULT_STATUS = 'backlog';
    
    // Eisenhower Matrix quadrants
    var QUADRANTS = [
      { id: 'q1', label: 'Do First', subtitle: 'Urgent & Important', color: '#ef4444', bg: '#fef2f2' },
      { id: 'q2', label: 'Schedule', subtitle: 'Not Urgent & Important', color: '#3b82f6', bg: '#eff6ff' },
      { id: 'q3', label: 'Delegate', subtitle: 'Urgent & Not Important', color: '#f59e0b', bg: '#fffbeb' },
      { id: 'q4', label: 'Eliminate', subtitle: 'Not Urgent & Not Important', color: '#6b7280', bg: '#f9fafb' }
    ];
    
    function genUUID() {
      return crypto.randomUUID ? crypto.randomUUID() : 
        'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0;
          return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    }

    function productivityApp() {
      return {
        items: [],
        locked: false,
        darkMode: false,
        inStandardNotes: false,
        sortBy: 'weight',
        viewMode: 'list',
        statuses: STATUSES,
        quadrants: QUADRANTS,
        defaultStatus: DEFAULT_STATUS,
        newTaskText: '',
        newSubtaskText: '',
        editingTaskId: null,
        editingTaskText: '',
        expandedTaskId: null,
        timerTick: 0,
        timerInterval: null,
        
        init() {
          var self = this;
          
          // Initialize the SN API (uses the proven working implementation)
          if (window.snApi) {
            console.log('[Productivity] Initializing sn-extension-api');
            
            try {
              snApi.initialize();
              
              snApi.subscribe(function(text, meta) {
                console.log('[Productivity] Note received from SN');
                self.inStandardNotes = true;
                
                if (text) {
                  try {
                    var data = JSON.parse(text);
                    if (data && data.version === 1 && Array.isArray(data.items)) {
                      self.items = data.items;
                    }
                  } catch (e) {
                    console.log('[Productivity] Parse error:', e);
                    self.items = [];
                  }
                } else {
                  self.items = [];
                }
                
                try {
                  self.locked = snApi.locked || false;
                } catch (e) {
                  self.locked = false;
                }
              });
            } catch (e) {
              console.log('[Productivity] SN init error:', e);
              this.loadFromStorage();
            }
          } else {
            console.log('[Productivity] snApi not available, using localStorage');
            this.loadFromStorage();
          }
          
          if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            this.darkMode = true;
          }
          var savedDarkMode = localStorage.getItem('sn-productivity-darkmode');
          if (savedDarkMode !== null) {
            this.darkMode = savedDarkMode === 'true';
          }
          
          this.timerInterval = setInterval(function() { self.timerTick++; }, 1000);
        },
        
        loadFromStorage() {
          try {
            var saved = localStorage.getItem('sn-productivity-items');
            if (saved) {
              var data = JSON.parse(saved);
              if (data && data.version === 1 && Array.isArray(data.items)) {
                this.items = data.items;
              }
            }
          } catch (e) {}
        },
        
        saveToStorage() {
          try {
            localStorage.setItem('sn-productivity-items', JSON.stringify({ version: 1, items: this.items }));
          } catch (e) {}
        },
        
        save() {
          this.saveToStorage();
          if (window.snApi && this.inStandardNotes) {
            try {
              snApi.text = JSON.stringify({ version: 1, items: this.items });
              snApi.preview = this.getPreview();
            } catch (e) {
              console.log('[Productivity] Save error:', e);
            }
          }
        },
        
        getPreview() {
          var incomplete = this.items.filter(function(t) { return !t.done; });
          if (incomplete.length === 0) return this.items.length > 0 ? 'All tasks completed!' : 'No tasks';
          var top = incomplete.slice(0, 3).map(function(t) { return '• ' + t.text; }).join('\n');
          if (incomplete.length > 3) top += '\n... and ' + (incomplete.length - 3) + ' more';
          return top;
        },
        
        toggleDarkMode() { this.darkMode = !this.darkMode; localStorage.setItem('sn-productivity-darkmode', this.darkMode.toString()); },
        toggleSort() { this.sortBy = this.sortBy === 'weight' ? 'dueDate' : 'weight'; },
        
        get sortedTasks() {
          var tasks = [...this.items];
          var self = this;
          var incomplete = tasks.filter(function(t) { return !t.done; });
          var completed = tasks.filter(function(t) { return t.done; });
          
          if (this.sortBy === 'dueDate') {
            incomplete.sort(function(a, b) {
              if (!a.dueDate && !b.dueDate) return b.weight - a.weight;
              if (!a.dueDate) return 1;
              if (!b.dueDate) return -1;
              var d = a.dueDate.localeCompare(b.dueDate);
              return d !== 0 ? d : b.weight - a.weight;
            });
          } else {
            incomplete.sort(function(a, b) { return b.weight - a.weight; });
          }
          completed.sort(function(a, b) {
            if (!a.completedAt && !b.completedAt) return 0;
            if (!a.completedAt) return 1;
            if (!b.completedAt) return -1;
            return b.completedAt.localeCompare(a.completedAt);
          });
          return incomplete.concat(completed);
        },
        
        get completedCount() { return this.items.filter(function(t) { return t.done; }).length; },
        get progressText() {
          var done = this.items.filter(function(t) { return t.done; }).length;
          return this.items.length === 0 ? '' : done + '/' + this.items.length + ' done';
        },
        
        addTask() {
          if (!this.newTaskText.trim() || this.locked) return;
          this.items.push({
            id: genUUID(), text: this.newTaskText.trim(), weight: 3, done: false,
            status: this.defaultStatus, subtasks: [], dueDate: null,
            estimatedMinutes: null, trackedSeconds: 0, timerStartedAt: null,
            createdAt: new Date().toISOString(), completedAt: null
          });
          this.newTaskText = '';
          this.save();
        },
        
        toggleTask(task) {
          if (this.locked) return;
          task.done = !task.done;
          task.completedAt = task.done ? new Date().toISOString() : null;
          if (task.done) { task.status = 'done'; if (task.timerStartedAt) this.stopTimer(task); }
          else if (task.status === 'done') { task.status = this.defaultStatus; }
          this.save();
        },
        
        deleteTask(task) {
          if (this.locked) return;
          var idx = this.items.findIndex(function(t) { return t.id === task.id; });
          if (idx !== -1) { this.items.splice(idx, 1); this.expandedTaskId = null; this.save(); }
        },
        
        startEditTask(task) {
          if (this.locked) return;
          this.editingTaskId = task.id;
          this.editingTaskText = task.text;
          var self = this;
          this.$nextTick(function() { var input = self.$refs.editInput; if (input) input.focus(); });
        },
        
        saveEditTask(task) {
          if (this.editingTaskText.trim()) { task.text = this.editingTaskText.trim(); this.save(); }
          this.editingTaskId = null; this.editingTaskText = '';
        },
        
        cancelEditTask() { this.editingTaskId = null; this.editingTaskText = ''; },
        increaseWeight(task) { if (this.locked || task.weight >= 5) return; task.weight++; this.save(); },
        decreaseWeight(task) { if (this.locked || task.weight <= 1) return; task.weight--; this.save(); },
        toggleExpanded(task) { this.expandedTaskId = this.expandedTaskId === task.id ? null : task.id; this.newSubtaskText = ''; },
        clearCompleted() { if (this.locked) return; this.items = this.items.filter(function(t) { return !t.done; }); this.save(); },
        
        addSubtask(task) {
          if (!this.newSubtaskText.trim() || this.locked) return;
          if (!task.subtasks) task.subtasks = [];
          task.subtasks.push({ id: genUUID(), text: this.newSubtaskText.trim(), done: false });
          this.newSubtaskText = '';
          this.save();
        },
        
        toggleSubtask(task, subtask) { if (this.locked) return; subtask.done = !subtask.done; this.save(); },
        deleteSubtask(task, subtask) {
          if (this.locked) return;
          var idx = task.subtasks.findIndex(function(s) { return s.id === subtask.id; });
          if (idx !== -1) { task.subtasks.splice(idx, 1); this.save(); }
        },
        
        getSubtaskProgress(task) {
          if (!task.subtasks || task.subtasks.length === 0) return '';
          return task.subtasks.filter(function(s) { return s.done; }).length + '/' + task.subtasks.length + ' subtasks';
        },
        
        setDueDate(task, date) { if (this.locked) return; task.dueDate = date || null; this.save(); },
        
        getDueDateClass(dueDate) {
          if (!dueDate) return '';
          var due = dayjs(dueDate), today = dayjs().startOf('day');
          if (due.isBefore(today)) return 'bg-red-500 text-white';
          if (due.isToday()) return 'bg-orange-500 text-white';
          if (due.isTomorrow()) return 'bg-yellow-500 text-white';
          return 'bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200';
        },
        
        getDueDateText(dueDate) {
          if (!dueDate) return '';
          var due = dayjs(dueDate), today = dayjs().startOf('day');
          if (due.isBefore(today)) return 'Overdue: ' + due.format('MMM D');
          if (due.isToday()) return 'Today';
          if (due.isTomorrow()) return 'Tomorrow';
          return due.format('MMM D');
        },
        
        startTimer(task) {
          if (this.locked || task.done) return;
          var running = this.items.find(function(t) { return t.timerStartedAt; });
          if (running && running.id !== task.id) this.stopTimer(running);
          task.timerStartedAt = new Date().toISOString();
          this.save();
        },
        
        stopTimer(task) {
          if (!task.timerStartedAt) return;
          var elapsed = Math.floor((new Date() - new Date(task.timerStartedAt)) / 1000);
          task.trackedSeconds = (task.trackedSeconds || 0) + elapsed;
          task.timerStartedAt = null;
          this.save();
        },
        
        formatTrackedTime(task) {
          var s = task.trackedSeconds || 0;
          var h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sec = s % 60;
          return h > 0 ? h + ':' + String(m).padStart(2, '0') + ':' + String(sec).padStart(2, '0') : m + ':' + String(sec).padStart(2, '0');
        },
        
        formatRunningTime(task) {
          if (!task.timerStartedAt) return '';
          var elapsed = Math.floor((new Date() - new Date(task.timerStartedAt)) / 1000);
          var total = (task.trackedSeconds || 0) + elapsed;
          var h = Math.floor(total / 3600), m = Math.floor((total % 3600) / 60), s = total % 60;
          return h > 0 ? h + ':' + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0') : m + ':' + String(s).padStart(2, '0');
        },
        
        parseTimeInput(input) {
          if (!input || !input.trim()) return null;
          input = input.trim().toLowerCase();
          var totalMinutes = 0;
          
          // Handle h:mm format
          var colonMatch = input.match(/^(\d+):(\d+)$/);
          if (colonMatch) {
            totalMinutes = parseInt(colonMatch[1]) * 60 + parseInt(colonMatch[2]);
            return totalMinutes > 0 ? totalMinutes : null;
          }
          
          // Handle 1h30m, 1h, 30m formats
          var hourMatch = input.match(/(\d+(?:\.\d+)?)\s*h/);
          var minMatch = input.match(/(\d+)\s*m/);
          if (hourMatch) totalMinutes += parseFloat(hourMatch[1]) * 60;
          if (minMatch) totalMinutes += parseInt(minMatch[1]);
          if (totalMinutes > 0) return Math.round(totalMinutes);
          
          // Handle plain number as minutes
          var numOnly = parseInt(input);
          if (!isNaN(numOnly) && numOnly > 0) return numOnly;
          
          return null;
        },
        
        setEstimate(task, input) {
          if (this.locked) return;
          task.estimatedMinutes = this.parseTimeInput(input);
          this.save();
        },
        
        formatEstimate(task) {
          if (!task.estimatedMinutes) return '';
          var hours = Math.floor(task.estimatedMinutes / 60);
          var mins = task.estimatedMinutes % 60;
          if (hours > 0 && mins > 0) return hours + 'h ' + mins + 'm';
          if (hours > 0) return hours + 'h';
          return mins + 'm';
        },
        
        getTasksByStatus(statusId) {
          var self = this;
          return this.items.filter(function(t) { return (t.status || self.defaultStatus) === statusId; })
            .sort(function(a, b) { return b.weight - a.weight; });
        },
        
        getStatusColor(statusId) {
          var status = this.statuses.find(function(s) { return s.id === statusId; });
          return status ? status.color : '#64748b';
        },
        
        getStatusLabel(statusId) {
          var status = this.statuses.find(function(s) { return s.id === statusId; });
          return status ? status.label : statusId;
        },
        
        setTaskStatus(task, statusId) {
          if (this.locked) return;
          task.status = statusId;
          if (statusId === 'done') {
            task.done = true;
            task.completedAt = task.completedAt || new Date().toISOString();
            if (task.timerStartedAt) this.stopTimer(task);
          } else { task.done = false; task.completedAt = null; }
          this.save();
        },
        
        getColumnCount(statusId) {
          var self = this;
          return this.items.filter(function(t) { return (t.status || self.defaultStatus) === statusId; }).length;
        },
        
        // Quadrant functions
        setTaskQuadrant(task, quadrantId) {
          if (this.locked) return;
          task.quadrant = quadrantId;
          this.save();
        },
        
        getTasksByQuadrant(quadrantId) {
          return this.items
            .filter(function(t) { return t.quadrant === quadrantId && !t.done; })
            .sort(function(a, b) { return b.weight - a.weight; });
        },
        
        getQuadrantCount(quadrantId) {
          return this.items.filter(function(t) { return t.quadrant === quadrantId && !t.done; }).length;
        },
        
        getQuadrantColor(quadrantId) {
          var quad = this.quadrants.find(function(q) { return q.id === quadrantId; });
          return quad ? quad.color : '#6b7280';
        },
        
        getQuadrantLabel(quadrantId) {
          var quad = this.quadrants.find(function(q) { return q.id === quadrantId; });
          return quad ? quad.label : '';
        },
        
        getUnassignedTasks() {
          return this.items
            .filter(function(t) { return !t.quadrant && !t.done; })
            .sort(function(a, b) { return b.weight - a.weight; });
        },
        
        onDropQuadrant(event, quadrantId) {
          event.preventDefault();
          if (this.draggedTask && !this.locked) {
            this.draggedTask.quadrant = quadrantId;
            this.save();
          }
          this.draggedTask = null;
        },
        
        draggedTask: null,
        onDragStart(event, task) {
          this.draggedTask = task;
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', task.id);
          event.target.style.opacity = '0.5';
        },
        onDragEnd(event) { event.target.style.opacity = '1'; this.draggedTask = null; },
        onDragOver(event) { event.preventDefault(); event.dataTransfer.dropEffect = 'move'; },
        onDrop(event, statusId) {
          event.preventDefault();
          if (this.draggedTask && !this.locked) this.setTaskStatus(this.draggedTask, statusId);
          this.draggedTask = null;
        }
      };
    }
  </script>
</body>
</html>
